#pragma once
#include "header.h"
class PerfectSquares
{
public:
    int numSquares(int n) {
        /*第279题：完全平方数
        * 动规法，用dp[i]表示要组成i需要的最小完全平方数个数（也是背包问题，用完全平方数来填满i，物品可重用）
        * 0. 递推公式：
        *    0.1 我们知道1是最小的完全平方数，所以要组成一个数i的最差结果就是通过全是1的完全平方数来组成，此时dp[i]=i
        *    0.2 i也可能是由含有其他值的完全平方数组成的，假设这个数是j，那么该完全平方数就是j*j，在这个前提下，此时j*j的结果就算组成i的1个数了，记1
        *        当j*j是组成i的一个完全平方数后，那么我们还剩下 i-j*j 的大小没有填满，而 i-j*j<i ，所以填满i-j*j的最小物品数其实我们前面已经算过了，也就是dp[i-j*j]
        *        所以在假设含有该j*j作为其中一个完全平方数的情况下，可以达到的最小数量为 min(dp[i], dp[i-j*j]+1)
        *    0.3 通过遍历i前面的所有可能的完全平方数作为背包中的其中一个元素，可以达到更新迭代dp[i]的效果，最终得到组成i的最小完全平方数
        */
        vector<int> dp(n + 1, 0);//因为还要存一个i=0的值，如果i刚好为完全平方数，j*j=i，那么它作为组成元素，剩下i-j*j=0的最小物品数是0，因此dp[0]初始化为0
        for (int i = 1; i <= n; i++) {//背包
            dp[i] = i;//最坏结果
            for (int j = 1; j * j <= i; j++) {//遍历i前面的所有可能的完全平方数j*j
                dp[i] = min(dp[i], dp[i - j * j] + 1);//i-j*j是除开当前背包j*j所需要填满的数
            }
        }
        return dp[n];
    }
};

