#include "UniqueBinarySearchTrees.h"

int UniqueBinarySearchTrees::numTrees(int n) {
	/*第96题：不同的二叉搜索树
	* 采用动规方法
	* 1. 动规数组的意义
	*	 以dp[i]表示当 n = i 时有可能出现的不同二叉树组合
	* 2. 递推公式
	*	 2.0. 首先我们将题目抽象出来：
	*		  将 输入n 可以看作是n个大于或等于1的各不相同的数（但实际上根据题目二叉树的最大值只能是n，这里只是为了方便理解）；
	*		  将 dp[i] 可以看作是当有i个数时可能组成的二叉树 “结构”，也就是不管填入的数值，而是将其直接抽象为一种结构
	*		  假设输入为n，那么可以以 1<= j <= n 作为树的头节点，当头节点确定后，我们来看头节点往下的左右半边的数值可能性：
	*			  a. 所有比j小的数都只能放在头节点的左半边，那么共有 j-1 个数放在左半边
	*			  b. 所有比j大的数都只能放在头节点的右半边，那么共有 i-j 个数放在右半边
	*		  那么此时我们就可以将左右半边独立开来，同时除掉头节点j，那么我们会发现求左半边可能出现的情况，其实就是求左半边 i-1 个节点可能组成的二叉树结构数
	*		  而我们前面已经说过了这些数是可以被抽象出来的，因此结构里填什么数字就不重要了，关键是我们知道左半边可以有dp[i-1]种二叉树结构;同理推出右半边可以有dp[i-j]种二叉树结构
	*		  所以在n个数的情况下，以j当头节点时共有 dp[i-1]*dp[i-j] 种二叉树结构
	*	 2.1 n=1 ：那么首先先推出当有n=1时，有1种二叉树结构，dp[1] = 1
	*			   已知n=1，那么作为头节点的就只有1一种可能，当头节点为1时，比1小的有0个数；比1大的有0个数。那么总共的组合结构就有 dp[1]=dp[0]*dp[0]=1 种
	*	 2.2 n=2 ：有2种二叉树结构							 dp[2] = 2
	*			   已知n=2，那么作为头节点的只有2一种可能：
	*			   2.2.1 当头节点为1：比1小的有0个数，比1大的放在右边有1个数。那么总共的组合结构就有 dp[0]*dp[1]=1 种
	*			   2.2.2 当头节点为2：比2小的有1个数，比2大的放在右边有0个数。那么总共的组合结构就有 dp[1]*dp[0]=1 种
	*			   所以当n=2时总共有 dp[2]=1+1=2 种情况（把所有可能作为头节点的情况全部加起来）
	*	 2.3 n=3 ：有5种二叉树结构							 dp[2] = 2
	*			   已知n=3，那么作为头节点的只有3一种可能：
	*			   2.3.1 当头节点为1：比1小的有0个数，比1大的放在右边有2个数。那么总共的组合结构就有 dp[0]*dp[2]=2 种
	*			   2.3.2 当头节点为2：比2小的有1个数，比2大的放在右边有1个数。那么总共的组合结构就有 dp[1]*dp[1]=1 种
	* 			   2.3.3 当头节点为3：比3小的有2个数，比3大的放在右边有0个数。那么总共的组合结构就有 dp[2]*dp[0]=2 种
	*			   所以当n=3时总共有 dp[3]=2+1+2=5 种情况（把所有可能作为头节点的情况全部加起来）
	*	 2.3 n   ：
	*			   总结规律，当n且j当头节点时，dp[n]+=dp[j-1]*dp[i-j];将左和右边的可能组合数相乘
	* 3. 初始化、遍历顺序
	*	 由推导公式可知求dp[n]需要知道小于n的dp值，同时公式中还需要dp[0]，所以首先初始化将dp[0]为1，再进行动规计算；遍历顺序是从i=1递增到i=n
	* 4. 返回：dp[n]
	*/
	vector<int> dp(n + 1, 0);
	dp[0] = 1;
	for (int i = 1; i <= n; i++) {//动规计算dp[i]
		for (int j = 1; j <= i; j++) {//循环计算取头节点为j的可能结构数
			dp[i] += dp[j - 1]*dp[i - j];
		}
	}
	return dp[n];
}

void UniqueBinarySearchTrees::test_UniqueBinarySearchTrees() {
	UniqueBinarySearchTrees UBST;
	for (int i = 1; i <= 3; i++) {
		cout << UBST.numTrees(i) << endl;
	}
}
