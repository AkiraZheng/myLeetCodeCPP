#include "RegularExpressionMatching_recursive.h"
bool RegularExpressionMatching_recursive::isMatch(const char* s, const char* p) {
	//注：这里的iaMatch函数代表的是输入的 (*s及其后面的char) 与 (*p及其后面的char) 相匹配，而不是单个字符s和p匹配
	//递归函数
	if (*p == '\0') return *s == '\0';//递归函数的出口，其中'/0'是字符串的结束标志

	//判断是否匹配
	//1. 当前符号是否匹配还与下一字符是否为'*'有关
	//1.1 若下一符号不是'*'：则当前符号必须相同，或者当前*p符号为通用符'.'才表示当前字符匹配
	if (*(p + 1) != '*') {
		if ((*p == '.' && *s != '\0') || (*p == *s)) {
			return isMatch(s + 1, p + 1);//判断下一个字符
		}
		else { return false; }//当前不匹配，直接返回false
	}
	//1.2 若下一个字符是'*'：则第一种情况是当前字符相匹配/当前字符是通用字符'.'；第二种情况是当前不匹配的情况下，下一字符的'*'代表0个
	//1.2 此时不管是两种情况中的哪种，都不会直接返回false，也就是'*'字符是一个匹配保障
	else {
		while((*p == '.' && *s != '\0') || (*p == *s)) {
			//第一种情况下，同样需要判断下一字符的'*'是否代表0
			//因为有可能出现s='aac'，p='a*aac'，此时'*'代表0，后面的依然匹配
			//换句话说，就是当isMatch(s, p+2)时，也就是当前s及其后面的字符与p+2及其后面的字符match时，这里的*应该表示0
			if (isMatch(s, p + 2)) return true;//前s及其后面的字符与p+2及其后面的字符match时，这里的*应该表示0，也代表后面的字符都匹配了，因此返回true
			//如果上述这里的*不表示0，那么还需要考虑这里的*到底代表几个，因此需要循环直到s中的重复字符结束为止
			s++;
		}
		//第二种情况下，表示当前p字符与当前s字符无法匹配，因此这里的*只能表示0，然后继续判断p下一个字符与当前s的匹配情况
		return isMatch(s, p + 2);//*符号代表一个重复的数值，而不是有意义的字符串，因此直接跳到p+2
	}
}